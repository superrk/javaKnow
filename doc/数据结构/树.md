<style>
h1,h2,h3,h4{
  color:#8f7f5d
}
</style>

参考 https://www.jianshu.com/p/912357993486

## 定义

树（tree）是包含 n（n>=0）个结点的有穷集，其中：

1. 每个元素称为结点（node）；
2. 有一个特定的结点被称为根结点或树根（root）。
3. 除根结点之外的其余数据元素被分为 m（m≥0）个互不相交的集合 T1，T2，……Tm-1，其中每一个集合 Ti（1<=i<=m）本身也是一棵树，被称作原树的子树（subtree）。

### 相关术语

- 节点的度：一个节点含有的子树的个数称为该节点的度；
- 叶节点或终端节点：度为 0 的节点称为叶节点；
- 非终端节点或分支节点：度不为 0 的节点；
- 双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；
- 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；
- 兄弟节点：具有相同父节点的节点互称为兄弟节点；
- 树的度：一棵树中，最大的节点的度称为树的度；
- 节点的层次：从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此类推；
- 树的高度或深度：树中节点的最大层次；
- 堂兄弟节点：双亲在同一层的节点互为堂兄弟；
- 节点的祖先：从根到该节点所经分支上的所有节点；
- 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。
- 森林：由 m（m>=0）棵互不相交的树的集合称为森林；
- 深度：定义一棵树的根结点层次为 1，其他节点的层次是其父结点层次加 1。一棵树中所有结点的层次的最大值称为这棵树的深度。

### 二叉树

每个结点至多拥有两棵子树(即二叉树中不存在度大于 2 的结点)，并且，二叉树的子树有左右之分，其次序不能任意颠倒。

二叉树的性质

1. 若二叉树的层次从 0 开始，则在二叉树的第 i 层至多有 2^i 个结点(i>=0)
2. 高度为 k 的二叉树最多有 2^(k+1) - 1 个结点(k>=-1)(空树的高度为-1)
3. 对任何一棵二叉树，如果其叶子结点(度为 0)数为 m, 度为 2 的结点数为 n, 则 m = n + 1
   二叉树又分为：完美二叉树，完全二叉树，完满二叉树
   完美二叉树(满二叉树)

二叉树的遍历方法

- 中序遍历：即左-根-右遍历，对于给定的二叉树根，寻找其左子树；对于其左子树的根，再去寻找其左子树；递归遍历，直到寻找最左边的节点 i，其必然为叶子，然后遍历 i 的父节点，再遍历 i 的兄弟节点。随着递归的逐渐出栈，最终完成遍历
- 先序遍历：即根-左-右遍历
- 后序遍历：即左-右-根遍历

#### 二叉查找树

二叉查找树也称为有序二叉查找树,满足二叉查找树的一般性质,是指一棵空树具有如下性质：

- 任意节点左子树不为空,则左子树的值均小于根节点的值
- 任意节点右子树不为空,则右子树的值均大于于根节点的值
- 任意节点的左右子树也分别是二叉查找树
- 没有键值相等的节点

局限性及应用
一个二叉查找树是由 n 个节点随机构成,所以，对于某些情况,二叉查找树会退化成一个有 n 个节点的线性链.如下图:
![线性链](./images/线性链.png 'some')

---

#### AVL 树(平衡二叉搜索树)

AVL 树是带有平衡条件的二叉查找树，和红黑树相比,它是严格的平衡二叉树,平衡条件必须满足(所有节点的左右子树高度差不超过 1).不管我们是执行插入还是删除操作,只要不满足上面的条件,就要通过旋转来保持平衡,而旋转是非常耗时的

使用场景：

- AVL 树适合用于插入删除次数比较少，但查找多的情况。
  也在 Windows 进程地址空间管理中得到了使用
- 旋转的目的是为了降低树的高度，使其平衡

AVL 树特点：

- AVL 树是一棵二叉搜索树
- AVL 树的左右子节点也是 AVL 树
- AVL 树拥有二叉搜索树的所有基本特点
- 每个节点的左右子节点的高度之差的绝对值最多为 1，即平衡因子为范围为[-1,1]

#### 红黑树

一种自平衡二叉查找树, 通过对任何一条从根到叶子的路径上各个节点着色的方式的限制,红黑树确保从根到叶子节点的最长路径不会是最短路径的两倍，用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决

使用场景：

红黑树多用于搜索,插入,删除操作多的情况下
红黑树应用比较广泛：

1. 广泛用在 C++的 STL 中。map 和 set 都是用红黑树实现的。
2. 著名的 linux 进程调度 Completely Fair Scheduler,用红黑树管理进程控制块。
3. epoll 在内核中的实现，用红黑树管理事件块
4. nginx 中，用红黑树管理 timer 等

原因：

红黑树的查询性能略微逊色于 AVL 树，因为比 AVL 树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的 AVL 树最多多一次比较，但是，红黑树在插入和删除上完爆 AVL 树，AVL 树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于 AVL 树为了维持平衡的开销要小得多

性质：

1. 节点是红色或黑色。
2. 根节点是黑色。
3. 每个叶子节点都是黑色的空节点（NIL 节点）。
4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

## B 树

B-树就是 B 树,-只是一个符号.

B 树(B-Tree)是一种自平衡的树,它是一种多路搜索树（并不是二叉的），能够保证数据有序。同时它还保证了在查找、插入、删除等操作时性能都能保持在 O(logn)，为大块数据的读写操作做了优化,同时它也可以用来描述外部存储(支持对保存在磁盘或者网络上的符号表进行外部查找)

特点：

1. 定义任意非叶子结点最多只有 M 个儿子；且 M>2
2. 根结点的儿子数为[2, M]
3. 除根结点以外的非叶子结点的儿子数为[M/2, M]
4. 每个结点存放至少 M/2-1（取上整）和至多 M-1 个关键字；（至少 2 个关键字）
5. 非叶子结点的关键字个数=指向儿子的指针个数-1
6. 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且 K[i] < K[i+1]
7. 非叶子结点的指针：P[1], P[2], …, P[M]，其中 P[1]指向关键字小于 K[1]的子树，P[M]指向关键字大于 K[M-1]的子树，其它 P[i]指向关键字属于(K[i-1], K[i])的子树
8. 所有叶子结点位于同一层

## B+树

B+树是 B-树的变体，也是一种多路搜索树

B+的搜索与 B-树也基本相同，区别是 B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；
B+的特性：

1. 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的
2. 不可能在非叶子结点命中
3. 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层
4. 更适合文件索引系统

原因： 增删文件（节点）时，效率更高，因为 B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率

B+ 树的优点：

1. 层级更低，IO 次数更少
2. 每次都需要查询到叶子节点，查询性能稳定
3. 叶子节点形成有序链表，范围查询方便
4. B+数插入和平衡
